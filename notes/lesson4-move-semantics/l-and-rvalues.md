# Lvalue and Rvalue

| L value | R value |
| ----- | ----- |
| has name - variable | no name - temporary value |
| can assign value | cannot assign value |
| some expression return l-value | some return r |
| persist beyond expression | no - meaning it will be lost if next line of code is executed. |
| function that returning reference returns l-value | function that returning value returs r-value.

<br />
<br />

## R value refernce
- represents a temporary where it is invoked by `&&` statement to r-value.
- R value reference can not bind to l-values but temporaries.
- Constant references can bind to temporaries
- In overloading functinos, the temporary will always bind to the function that accepts R-value reference. ( temporary reference > const l-value reference )
```cpp
int &&r1 = 10;
int &&r2 = Add(5,8); // if Add() returns r-value.
int &&r3 = 7 + 2; // expressions which return r-value.
```

## Why do we use R value reference
- By using R value reference, we can implement **move semantics** which is a faster way of copying the temporary objects.
- Why faster? because we don't do deep copy as the copy constructor do.

### Example
```cpp
// Integer.cpp
Integer::Integer(Integer && obj){
  m_pInt = obj.m_pInt; // Do all shallow copy here. No new resource is allocated.
  obj.m_pInt = nullptr; // Make all original ptr to point null so copied temporary object will not be clashed when temporary object calls destructor.
}
```

## Resource Mangement
- In destruction, the resources must be released to avoid memory leak.
- Similarly, we need to take action for any resources during contructor, copy constructor and move.

### Rule of 5.
- If a class has ownership semantics, you must provide a user-difined:
  - destructor, copy constructor, copy assignment operator, move constructor, move assignment operator.

#### Rule 0
- **If a class does not have ownership semantics, then do not provide any user-defined function because the compiler will synthesize automatically.**
  - If you provide custom move operation, the compiler will delete default copy constructor and move operation in component class as well.
  - If you need to prove custom move operation, but you still want to use default copy constructor, you have to define `default` statements in the copy copy contructor.
  - **Note:** default keyword works only on those functions that can be implicitly generated. *Parameterized constructors* can never be generated by the compiler.
  - e.g. `Number & operator=(Number && obj) = default;` in the class.
  - On the other hand, if you have custom copy constructor, the compiler will delete custom move operation and it will deep copy always although the move operation is needed.

#### Other rules
| Custom \ Synthesized | Cpy Constr | Cpy Assign | Mov Constr | Cpy Assignment | Destructor |
| :---                 | ---        | ---        | ---        | ---            | ---        |
| **Cpy Constr**       | Custom     | =default   | =delete    | =delete        | =default   |
| **Cpy Assign**       | =default   | =delete    | =delete    | =delete        | =default   |
| **Mov Constr**       | =delete    | =delete    | Custom     | =delete        | =default   |
| **Mov Assignment**   | =delete    | =delete    | =delete    | Custom         | =default   |
| **Destructor**       | =default   | =default   | =delete    | =delete        | Custom     |



